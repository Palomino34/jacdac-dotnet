/** Autogenerated file. Do not edit. */
using Jacdac;
using System;

namespace Jacdac {

    /// <summary>
    /// Discovery and connection to WiFi networks. Separate TCP service can be used for data transfer.
     /// 
     /// The device controlled by this service is meant to connect automatically, once configured.
     /// To that end, it keeps a list of known WiFi networks, with priorities and passwords.
     /// It will connect to the available network with numerically highest priority,
     /// breaking ties in priority by signal strength (typically all known networks have priority of `0`).
     /// If the connection fails (due to wrong password, radio failure, or other problem)
     /// an `connection_failed` event is emitted, and the device will try to connect to the next eligible network.
     /// When networks are exhausted, the scan is performed again and the connection process restarts.
     /// 
     /// Updating networks (setting password, priorties, forgetting) does not trigger an automatic reconnect.
    /// Implements a client for the WIFI service.
    /// </summary>
    /// <seealso cref="https://microsoft.github.io/jacdac-docs/services/wifi/" />
    public partial class WifiClient : Client
    {
        public WifiClient(JDBus bus, string name)
            : base(bus, ServiceClasses.Wifi, name)
        {
        }

        /// <summary>
        /// Determines whether the WiFi radio is enabled. It starts enabled upon reset., 
        /// </summary>
        public bool Enabled
        {
            get
            {
                return (bool)this.GetRegisterValue((ushort)WifiReg.Enabled, WifiRegPack.Enabled, 1);
            }
            set
            {
                
                this.SetRegisterValue((ushort)WifiReg.Enabled, WifiRegPack.Enabled, 1, value);
            }

        }

        /// <summary>
        /// 0, 4 or 16 byte buffer with the IPv4 or IPv6 address assigned to device if any., 
        /// </summary>
        public byte[] IpAddress
        {
            get
            {
                return (byte[])this.GetRegisterValue((ushort)WifiReg.IpAddress, WifiRegPack.IpAddress, 1);
            }
        }

        /// <summary>
        /// The 6-byte MAC address of the device. If a device does MAC address randomization it will have to "restart"., 
        /// </summary>
        public byte[] Eui48
        {
            get
            {
                return (byte[])this.GetRegisterValue((ushort)WifiReg.Eui48, WifiRegPack.Eui48, 1);
            }
        }

        /// <summary>
        /// SSID of the access-point to which device is currently connected.
        /// Empty string if not connected., 
        /// </summary>
        public string Ssid
        {
            get
            {
                return (string)this.GetRegisterValue((ushort)WifiReg.Ssid, WifiRegPack.Ssid, 1);
            }
        }

        /// <summary>
        /// Current signal strength. Returns -128 when not connected., _: dB
        /// </summary>
        public int Rssi
        {
            get
            {
                return (int)this.GetRegisterValue((ushort)WifiReg.Rssi, WifiRegPack.Rssi, 1);
            }
        }

        /// <summary>
        /// Emitted upon successful join and IP address assignment.
        /// </summary>
        public event NodeEventHandler GotIp;

        /// <summary>
        /// Emitted when disconnected from network.
        /// </summary>
        public event NodeEventHandler LostIp;

        /// <summary>
        /// A WiFi network scan has completed. Results can be read with the `last_scan_results` command.
        /// The event indicates how many networks where found, and how many are considered
        /// as candidates for connection.
        /// </summary>
        public event NodeEventHandler ScanComplete;

        /// <summary>
        /// Emitted whenever the list of known networks is updated.
        /// </summary>
        public event NodeEventHandler NetworksChanged;

        /// <summary>
        /// Emitted when when a network was detected in scan, the device tried to connect to it
        /// and failed.
        /// This may be because of wrong password or other random failure.
        /// </summary>
        public event NodeEventHandler ConnectionFailed;


        /// <summary>
        /// Automatically connect to named network if available. Also set password if network is not open.
        /// </summary>
        public void AddNetwork(string ssid, string password)
        {
            this.SendCmdPacked((ushort)WifiCmd.AddNetwork, WifiCmdPack.AddNetwork, new object[] { ssid, password });
        }

        /// <summary>
        /// Enable the WiFi (if disabled), initiate a scan, wait for results, disconnect from current WiFi network if any,
        /// and then reconnect (using regular algorithm, see `set_network_priority`).
        /// </summary>
        public void Reconnect()
        {
            this.SendCmdPacked((ushort)WifiCmd.Reconnect, WifiCmdPack.Reconnect, new object[] {  });
        }

        /// <summary>
        /// Prevent from automatically connecting to named network in future.
        /// Forgetting a network resets its priority to `0`.
        /// </summary>
        public void ForgetNetwork(string ssid)
        {
            this.SendCmdPacked((ushort)WifiCmd.ForgetNetwork, WifiCmdPack.ForgetNetwork, new object[] { ssid });
        }

        /// <summary>
        /// Clear the list of known networks.
        /// </summary>
        public void ForgetAllNetworks()
        {
            this.SendCmdPacked((ushort)WifiCmd.ForgetAllNetworks, WifiCmdPack.ForgetAllNetworks, new object[] {  });
        }

        /// <summary>
        /// Set connection priority for a network.
        /// By default, all known networks have priority of `0`.
        /// </summary>
        public void SetNetworkPriority(int priority, string ssid)
        {
            this.SendCmdPacked((ushort)WifiCmd.SetNetworkPriority, WifiCmdPack.SetNetworkPriority, new object[] { priority, ssid });
        }

        /// <summary>
        /// Initiate search for WiFi networks. Generates `scan_complete` event.
        /// </summary>
        public void Scan()
        {
            this.SendCmdPacked((ushort)WifiCmd.Scan, WifiCmdPack.Scan, new object[] {  });
        }

    }
}